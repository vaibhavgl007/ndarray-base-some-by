{
  "version": 3,
  "sources": ["../lib/2d_blocked_accessors.js", "../lib/3d_blocked_accessors.js", "../lib/4d_blocked_accessors.js", "../lib/5d_blocked_accessors.js", "../lib/6d_blocked_accessors.js", "../lib/7d_blocked_accessors.js", "../lib/8d_blocked_accessors.js", "../lib/9d_blocked_accessors.js", "../lib/10d_blocked_accessors.js", "../lib/2d_blocked.js", "../lib/3d_blocked.js", "../lib/4d_blocked.js", "../lib/5d_blocked.js", "../lib/6d_blocked.js", "../lib/7d_blocked.js", "../lib/8d_blocked.js", "../lib/9d_blocked.js", "../lib/10d_blocked.js", "../lib/0d_accessors.js", "../lib/1d_accessors.js", "../lib/2d_accessors.js", "../lib/3d_accessors.js", "../lib/4d_accessors.js", "../lib/5d_accessors.js", "../lib/6d_accessors.js", "../lib/7d_accessors.js", "../lib/8d_accessors.js", "../lib/9d_accessors.js", "../lib/10d_accessors.js", "../lib/nd_accessors.js", "../lib/0d.js", "../lib/1d.js", "../lib/2d.js", "../lib/3d.js", "../lib/4d.js", "../lib/5d.js", "../lib/6d.js", "../lib/7d.js", "../lib/8d.js", "../lib/9d.js", "../lib/10d.js", "../lib/nd.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/* eslint-disable max-depth */\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'generic',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome2d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome2d( x, n, predicate, thisArg ) {\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar ox1;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tox1 = ox + ( j1*sx[1] );\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t// Compute the loop offset increment:\n\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t// Iterate over the ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tix += dx0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome2d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 2, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'generic',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome3d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome3d( x, n, predicate, thisArg ) {\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar ox1;\n\tvar ox2;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tox2 = ox + ( j2*sx[2] );\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t// Compute the loop offset increment:\n\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome3d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome4d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome4d( x, n, predicate, thisArg ) {\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tox3 = ox + ( j3*sx[3] );\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome4d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome5d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome5d( x, n, predicate, thisArg ) {\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tox4 = ox + ( j4*sx[4] );\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome5d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome6d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome6d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tox5 = ox + ( j5*sx[5] );\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome6d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome7d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome7d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tox6 = ox + ( j6*sx[6] );\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome7d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome8d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome8d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tox7 = ox + ( j7*sx[7] );\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome8d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome9d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome9d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tox8 = ox + ( j8*sx[8] );\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j8+i8, j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome9d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = blockedsome10d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome10d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar ox9;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tox9 = ox + ( j9*sx[9] );\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tdx9 = sx[9] - ( s8*sx[8] );\n\t\t\tox8 = ox9 + ( j8*sx[8] );\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ j9+i9, j8+i8, j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome10d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/* eslint-disable max-depth */\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome2d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome2d( x, n, predicate, thisArg ) {\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar ox1;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tox1 = ox + ( j1*sx[1] );\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t// Compute the loop offset increment:\n\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t// Iterate over the ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tix += dx0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome2d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome3d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome3d( x, n, predicate, thisArg ) {\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar ox1;\n\tvar ox2;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tox2 = ox + ( j2*sx[2] );\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t// Compute the loop offset increment:\n\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome3d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome4d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome4d( x, n, predicate, thisArg ) {\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tox3 = ox + ( j3*sx[3] );\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome4d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome5d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome5d( x, n, predicate, thisArg ) {\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tox4 = ox + ( j4*sx[4] );\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome5d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome6d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome6d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tox5 = ox + ( j5*sx[5] );\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome6d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome7d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome7d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tox6 = ox + ( j6*sx[6] );\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome7d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome8d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome8d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tox7 = ox + ( j7*sx[7] );\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome8d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome9d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome9d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tox8 = ox + ( j8*sx[8] );\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j8+i8, j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome9d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-nullary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-nullary-tiling-block-size' );\nvar take = require( '@stdlib/array-base-take-indexed' );\nvar reverse = require( '@stdlib/array-base-reverse' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = blockedsome10d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction blockedsome10d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar ox9;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tox9 = ox + ( j9*sx[9] );\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tdx9 = sx[9] - ( s8*sx[8] );\n\t\t\tox8 = ox9 + ( j8*sx[8] );\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute the index offset for the first input ndarray element in the current block:\n\t\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ j9+i9, j8+i8, j7+i7, j6+i6, j5+i5, j4+i4, j3+i3, j2+i2, j1+i1, j0+i0 ], idx ), x.ref ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedsome10d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [];\n*\n* // Define the array strides:\n* var sx = [ 0 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'generic',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some0d( x, 1, predicate, {} );\n* // returns true\n*/\nfunction some0d( x, n, predicate, thisArg ) {\n\tif ( n === 1 && predicate.call( thisArg, x.accessors[ 0 ]( x.data, x.offset ), [], x.ref ) ) { // eslint-disable-line max-len\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some0d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 4 ];\n*\n* // Define the array strides:\n* var sx = [ 2 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'generic',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some1d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some1d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar S0;\n\tvar ix;\n\tvar i0;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables: dimensions and loop offset (pointer) increments...\n\tS0 = x.shape[ 0 ];\n\tdx0 = x.strides[ 0 ];\n\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tif ( predicate.call( thisArg, get( xbuf, ix ), [ i0 ], x.ref ) ) {\n\t\t\tcount += 1;\n\t\t\tif ( count === n ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tix += dx0;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some1d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'generic',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some2d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some2d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdx0 = sx[ 1 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 0 ] - ( S0*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\tcount += 1;\n\t\t\t\tif ( count === n ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tix += dx0;\n\t\t}\n\t\tix += dx1;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some2d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 2, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'generic',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some3d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some3d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdx0 = sx[ 2 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx2 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\tcount += 1;\n\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix += dx0;\n\t\t\t}\n\t\t\tix += dx1;\n\t\t}\n\t\tix += dx2;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some3d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/* eslint-disable max-depth */\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some4d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some4d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdx0 = sx[ 3 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 2 ] - ( S0*sx[3] );\n\t\tdx2 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx3 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tix += dx0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t}\n\t\t\tix += dx2;\n\t\t}\n\t\tix += dx3;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some4d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some5d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some5d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdx0 = sx[ 4 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 3 ] - ( S0*sx[4] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[3] );\n\t\tdx3 = sx[ 1 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 0 ] - ( S3*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx1;\n\t\t\t\t}\n\t\t\t\tix += dx2;\n\t\t\t}\n\t\t\tix += dx3;\n\t\t}\n\t\tix += dx4;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some5d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some6d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some6d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdx0 = sx[ 5 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 4 ] - ( S0*sx[5] );\n\t\tdx2 = sx[ 3 ] - ( S1*sx[4] );\n\t\tdx3 = sx[ 2 ] - ( S2*sx[3] );\n\t\tdx4 = sx[ 1 ] - ( S3*sx[2] );\n\t\tdx5 = sx[ 0 ] - ( S4*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t}\n\t\t\t\tix += dx3;\n\t\t\t}\n\t\t\tix += dx4;\n\t\t}\n\t\tix += dx5;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some6d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some7d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some7d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdx0 = sx[ 6 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 5 ] - ( S0*sx[6] );\n\t\tdx2 = sx[ 4 ] - ( S1*sx[5] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[4] );\n\t\tdx4 = sx[ 2 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 1 ] - ( S4*sx[2] );\n\t\tdx6 = sx[ 0 ] - ( S5*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx3;\n\t\t\t\t}\n\t\t\t\tix += dx4;\n\t\t\t}\n\t\t\tix += dx5;\n\t\t}\n\t\tix += dx6;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some7d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some8d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some8d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdx0 = sx[ 7 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 6 ] - ( S0*sx[7] );\n\t\tdx2 = sx[ 5 ] - ( S1*sx[6] );\n\t\tdx3 = sx[ 4 ] - ( S2*sx[5] );\n\t\tdx4 = sx[ 3 ] - ( S3*sx[4] );\n\t\tdx5 = sx[ 2 ] - ( S4*sx[3] );\n\t\tdx6 = sx[ 1 ] - ( S5*sx[2] );\n\t\tdx7 = sx[ 0 ] - ( S6*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx4;\n\t\t\t\t}\n\t\t\t\tix += dx5;\n\t\t\t}\n\t\t\tix += dx6;\n\t\t}\n\t\tix += dx7;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some8d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-statements */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some9d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some9d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdx0 = sx[ 8 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 7 ] - ( S0*sx[8] );\n\t\tdx2 = sx[ 6 ] - ( S1*sx[7] );\n\t\tdx3 = sx[ 5 ] - ( S2*sx[6] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[5] );\n\t\tdx5 = sx[ 3 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 2 ] - ( S5*sx[3] );\n\t\tdx7 = sx[ 1 ] - ( S6*sx[2] );\n\t\tdx8 = sx[ 0 ] - ( S7*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx5;\n\t\t\t\t}\n\t\t\t\tix += dx6;\n\t\t\t}\n\t\t\tix += dx7;\n\t\t}\n\t\tix += dx8;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some9d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] ) );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = some10d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some10d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdx0 = sx[ 9 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 8 ] - ( S0*sx[9] );\n\t\tdx2 = sx[ 7 ] - ( S1*sx[8] );\n\t\tdx3 = sx[ 6 ] - ( S2*sx[7] );\n\t\tdx4 = sx[ 5 ] - ( S3*sx[6] );\n\t\tdx5 = sx[ 4 ] - ( S4*sx[5] );\n\t\tdx6 = sx[ 3 ] - ( S5*sx[4] );\n\t\tdx7 = sx[ 2 ] - ( S6*sx[3] );\n\t\tdx8 = sx[ 1 ] - ( S7*sx[2] );\n\t\tdx9 = sx[ 0 ] - ( S8*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] );\n\t\tdx9 = sx[ 9 ] - ( S8*sx[8] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, get( xbuf, ix ), take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx6;\n\t\t\t\t}\n\t\t\t\tix += dx7;\n\t\t\t}\n\t\t\tix += dx8;\n\t\t}\n\t\tix += dx9;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some10d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar vind2bind = require( '@stdlib/ndarray-base-vind2bind' );\nvar ind2sub = require( '@stdlib/ndarray-base-ind2sub' );\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var accessors = require( '@stdlib/array-base-accessors' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = toAccessorArray( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'generic',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': accessors( xbuf ).accessors\n* };\n*\n* // Test elements:\n* var out = somend( x, 2, predicate, {} );\n* // returns true\n*/\nfunction somend( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar ordx;\n\tvar idx;\n\tvar len;\n\tvar get;\n\tvar sh;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i;\n\n\tsh = x.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Cache a reference to the input ndarray data buffer:\n\txbuf = x.data;\n\n\t// Cache a reference to the stride array:\n\tsx = x.strides;\n\n\t// Cache the index of the first indexed element:\n\tox = x.offset;\n\n\t// Cache the array order:\n\tordx = x.order;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over each element based on the linear **view** index, regardless as to how the data is stored in memory...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tix = vind2bind( sh, sx, ox, ordx, i, MODE );\n\t\tidx = ind2sub( sh, sx, 0, ordx, i, MODE ); // return subscripts from the perspective of the ndarray view\n\t\tif ( predicate.call( thisArg, get( xbuf, ix ), idx, x.ref ) ) {\n\t\t\tcount += 1;\n\t\t\tif ( count === n ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = somend;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [];\n*\n* // Define the array strides:\n* var sx = [ 0 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some0d( x, 1, predicate, {} );\n* // returns true\n*/\nfunction some0d( x, n, predicate, thisArg ) {\n\tif ( n === 1 && predicate.call( thisArg, x.data[ x.offset ], [], x.ref ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some0d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 4 ];\n*\n* // Define the array strides:\n* var sx = [ 2 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some1d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some1d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar dx0;\n\tvar S0;\n\tvar ix;\n\tvar i0;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables: dimensions and loop offset (pointer) increments:\n\tS0 = x.shape[ 0 ];\n\tdx0 = x.strides[ 0 ];\n\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tif ( predicate.call( thisArg, xbuf[ ix ], [ i0 ], x.ref ) ) {\n\t\t\tcount += 1;\n\t\t\tif ( count === n ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tix += dx0;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some1d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some2d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some2d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdx0 = sx[ 1 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 0 ] - ( S0*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\tcount += 1;\n\t\t\t\tif ( count === n ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tix += dx0;\n\t\t}\n\t\tix += dx1;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some2d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some3d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some3d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdx0 = sx[ 2 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx2 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\tcount += 1;\n\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix += dx0;\n\t\t\t}\n\t\t\tix += dx1;\n\t\t}\n\t\tix += dx2;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some3d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/* eslint-disable max-depth */\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some4d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some4d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdx0 = sx[ 3 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 2 ] - ( S0*sx[3] );\n\t\tdx2 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx3 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tix += dx0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t}\n\t\t\tix += dx2;\n\t\t}\n\t\tix += dx3;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some4d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some5d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some5d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdx0 = sx[ 4 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 3 ] - ( S0*sx[4] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[3] );\n\t\tdx3 = sx[ 1 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 0 ] - ( S3*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx1;\n\t\t\t\t}\n\t\t\t\tix += dx2;\n\t\t\t}\n\t\t\tix += dx3;\n\t\t}\n\t\tix += dx4;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some5d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some6d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some6d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdx0 = sx[ 5 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 4 ] - ( S0*sx[5] );\n\t\tdx2 = sx[ 3 ] - ( S1*sx[4] );\n\t\tdx3 = sx[ 2 ] - ( S2*sx[3] );\n\t\tdx4 = sx[ 1 ] - ( S3*sx[2] );\n\t\tdx5 = sx[ 0 ] - ( S4*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t}\n\t\t\t\tix += dx3;\n\t\t\t}\n\t\t\tix += dx4;\n\t\t}\n\t\tix += dx5;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some6d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some7d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some7d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdx0 = sx[ 6 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 5 ] - ( S0*sx[6] );\n\t\tdx2 = sx[ 4 ] - ( S1*sx[5] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[4] );\n\t\tdx4 = sx[ 2 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 1 ] - ( S4*sx[2] );\n\t\tdx6 = sx[ 0 ] - ( S5*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx3;\n\t\t\t\t}\n\t\t\t\tix += dx4;\n\t\t\t}\n\t\t\tix += dx5;\n\t\t}\n\t\tix += dx6;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some7d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some8d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some8d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdx0 = sx[ 7 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 6 ] - ( S0*sx[7] );\n\t\tdx2 = sx[ 5 ] - ( S1*sx[6] );\n\t\tdx3 = sx[ 4 ] - ( S2*sx[5] );\n\t\tdx4 = sx[ 3 ] - ( S3*sx[4] );\n\t\tdx5 = sx[ 2 ] - ( S4*sx[3] );\n\t\tdx6 = sx[ 1 ] - ( S5*sx[2] );\n\t\tdx7 = sx[ 0 ] - ( S6*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx4;\n\t\t\t\t}\n\t\t\t\tix += dx5;\n\t\t\t}\n\t\t\tix += dx6;\n\t\t}\n\t\tix += dx7;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some8d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some9d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some9d( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdx0 = sx[ 8 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 7 ] - ( S0*sx[8] );\n\t\tdx2 = sx[ 6 ] - ( S1*sx[7] );\n\t\tdx3 = sx[ 5 ] - ( S2*sx[6] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[5] );\n\t\tdx5 = sx[ 3 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 2 ] - ( S5*sx[3] );\n\t\tdx7 = sx[ 1 ] - ( S6*sx[2] );\n\t\tdx8 = sx[ 0 ] - ( S7*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx5;\n\t\t\t\t}\n\t\t\t\tix += dx6;\n\t\t\t}\n\t\t\tix += dx7;\n\t\t}\n\t\tix += dx8;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some9d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar zeroTo = require( '@stdlib/array-base-zero-to' );\nvar reverse = require( '@stdlib/array-base-reverse' );\nvar take = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = some10d( x, 4, predicate, {} );\n* // returns true\n*/\nfunction some10d( x, n, predicate, thisArg ) { // eslint-disable-line max-statements\n\tvar count;\n\tvar xbuf;\n\tvar idx;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdx0 = sx[ 9 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 8 ] - ( S0*sx[9] );\n\t\tdx2 = sx[ 7 ] - ( S1*sx[8] );\n\t\tdx3 = sx[ 6 ] - ( S2*sx[7] );\n\t\tdx4 = sx[ 5 ] - ( S3*sx[6] );\n\t\tdx5 = sx[ 4 ] - ( S4*sx[5] );\n\t\tdx6 = sx[ 3 ] - ( S5*sx[4] );\n\t\tdx7 = sx[ 2 ] - ( S6*sx[3] );\n\t\tdx8 = sx[ 1 ] - ( S7*sx[2] );\n\t\tdx9 = sx[ 0 ] - ( S8*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] );\n\t\tdx9 = sx[ 9 ] - ( S8*sx[8] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the input ndarray buffer:\n\txbuf = x.data;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( predicate.call( thisArg, xbuf[ ix ], take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ) ) { // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tif ( count === n ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx6;\n\t\t\t\t}\n\t\t\t\tix += dx7;\n\t\t\t}\n\t\t\tix += dx8;\n\t\t}\n\t\tix += dx9;\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = some10d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar vind2bind = require( '@stdlib/ndarray-base-vind2bind' );\nvar ind2sub = require( '@stdlib/ndarray-base-ind2sub' );\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {PositiveInteger} n - number of elements\n* @param {Function} predicate - predicate function\n* @param {*} thisArg - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Test elements:\n* var out = somend( x, 2, predicate, {} );\n* // returns true\n*/\nfunction somend( x, n, predicate, thisArg ) {\n\tvar count;\n\tvar xbuf;\n\tvar ordx;\n\tvar idx;\n\tvar len;\n\tvar sh;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i;\n\n\tsh = x.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Cache a reference to the input ndarray data buffer:\n\txbuf = x.data;\n\n\t// Cache a reference to the stride array:\n\tsx = x.strides;\n\n\t// Cache the index of the first indexed element:\n\tox = x.offset;\n\n\t// Cache the array order:\n\tordx = x.order;\n\n\t// Initialize a counter:\n\tcount = 0;\n\n\t// Iterate over each element based on the linear **view** index, regardless as to how the data is stored in memory...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tix = vind2bind( sh, sx, ox, ordx, i, MODE );\n\t\tidx = ind2sub( sh, sx, 0, ordx, i, MODE ); // return subscripts from the perspective of the ndarray view\n\t\tif ( predicate.call( thisArg, xbuf[ ix ], idx, x.ref ) ) {\n\t\t\tcount += 1;\n\t\t\tif ( count === n ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// EXPORTS //\n\nmodule.exports = somend;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar iterationOrder = require( '@stdlib/ndarray-base-iteration-order' );\nvar ndarray2object = require( '@stdlib/ndarray-base-ndarraylike2object' );\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar blockedaccessorsome2d = require( './2d_blocked_accessors.js' );\nvar blockedaccessorsome3d = require( './3d_blocked_accessors.js' );\nvar blockedaccessorsome4d = require( './4d_blocked_accessors.js' );\nvar blockedaccessorsome5d = require( './5d_blocked_accessors.js' );\nvar blockedaccessorsome6d = require( './6d_blocked_accessors.js' );\nvar blockedaccessorsome7d = require( './7d_blocked_accessors.js' );\nvar blockedaccessorsome8d = require( './8d_blocked_accessors.js' );\nvar blockedaccessorsome9d = require( './9d_blocked_accessors.js' );\nvar blockedaccessorsome10d = require( './10d_blocked_accessors.js' );\nvar blockedsome2d = require( './2d_blocked.js' );\nvar blockedsome3d = require( './3d_blocked.js' );\nvar blockedsome4d = require( './4d_blocked.js' );\nvar blockedsome5d = require( './5d_blocked.js' );\nvar blockedsome6d = require( './6d_blocked.js' );\nvar blockedsome7d = require( './7d_blocked.js' );\nvar blockedsome8d = require( './8d_blocked.js' );\nvar blockedsome9d = require( './9d_blocked.js' );\nvar blockedsome10d = require( './10d_blocked.js' );\nvar accessorsome0d = require( './0d_accessors.js' );\nvar accessorsome1d = require( './1d_accessors.js' );\nvar accessorsome2d = require( './2d_accessors.js' );\nvar accessorsome3d = require( './3d_accessors.js' );\nvar accessorsome4d = require( './4d_accessors.js' );\nvar accessorsome5d = require( './5d_accessors.js' );\nvar accessorsome6d = require( './6d_accessors.js' );\nvar accessorsome7d = require( './7d_accessors.js' );\nvar accessorsome8d = require( './8d_accessors.js' );\nvar accessorsome9d = require( './9d_accessors.js' );\nvar accessorsome10d = require( './10d_accessors.js' );\nvar accessorsomend = require( './nd_accessors.js' );\nvar some0d = require( './0d.js' );\nvar some1d = require( './1d.js' );\nvar some2d = require( './2d.js' );\nvar some3d = require( './3d.js' );\nvar some4d = require( './4d.js' );\nvar some5d = require( './5d.js' );\nvar some6d = require( './6d.js' );\nvar some7d = require( './7d.js' );\nvar some8d = require( './8d.js' );\nvar some9d = require( './9d.js' );\nvar some10d = require( './10d.js' );\nvar somend = require( './nd.js' );\n\n\n// VARIABLES //\n\nvar SOME = [\n\tsome0d,\n\tsome1d,\n\tsome2d,\n\tsome3d,\n\tsome4d,\n\tsome5d,\n\tsome6d,\n\tsome7d,\n\tsome8d,\n\tsome9d,\n\tsome10d\n];\nvar ACCESSOR_SOME = [\n\taccessorsome0d,\n\taccessorsome1d,\n\taccessorsome2d,\n\taccessorsome3d,\n\taccessorsome4d,\n\taccessorsome5d,\n\taccessorsome6d,\n\taccessorsome7d,\n\taccessorsome8d,\n\taccessorsome9d,\n\taccessorsome10d\n];\nvar BLOCKED_SOME = [\n\tblockedsome2d, // 0\n\tblockedsome3d,\n\tblockedsome4d,\n\tblockedsome5d,\n\tblockedsome6d,\n\tblockedsome7d,\n\tblockedsome8d,\n\tblockedsome9d,\n\tblockedsome10d // 8\n];\nvar BLOCKED_ACCESSOR_SOME = [\n\tblockedaccessorsome2d, // 0\n\tblockedaccessorsome3d,\n\tblockedaccessorsome4d,\n\tblockedaccessorsome5d,\n\tblockedaccessorsome6d,\n\tblockedaccessorsome7d,\n\tblockedaccessorsome8d,\n\tblockedaccessorsome9d,\n\tblockedaccessorsome10d // 8\n];\nvar MAX_DIMS = SOME.length - 1;\n\n\n// MAIN //\n\n/**\n* Tests whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* ## Notes\n*\n* -   A provided ndarray should be an `object` with the following properties:\n*\n*     -   **dtype**: data type.\n*     -   **data**: data buffer.\n*     -   **shape**: dimensions.\n*     -   **strides**: stride lengths.\n*     -   **offset**: index offset.\n*     -   **order**: specifies whether an ndarray is row-major (C-style) or column major (Fortran-style).\n*\n* @param {ArrayLikeObject<Object>} arrays - array-like object containing an input ndarray and a zero-dimensional ndarray specifying the minimum number of elements in the input ndarray that must satisfy the predicate function\n* @param {Function} predicate - predicate function\n* @param {thisArg} [thisArg] - predicate function execution context\n* @returns {boolean} boolean indicating whether at least `n` elements pass a test\n*\n* @example\n* var scalar2ndarray = require( '@stdlib/ndarray-from-scalar' );\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 0.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Define the success criterion:\n* var n = scalar2ndarray( 3, {\n*     'dtype': 'generic'\n* });\n*\n* // Test elements:\n* var out = someBy( [ x, n ], predicate );\n* // returns true\n*/\nfunction someBy( arrays, predicate, thisArg ) {\n\tvar ndims;\n\tvar shx;\n\tvar x;\n\tvar n;\n\tvar N;\n\n\t// Unpack the ndarray and standardize ndarray meta data:\n\tx = ndarray2object( arrays[ 0 ] );\n\tn = ndarray2object( arrays[ 1 ] );\n\n\tshx = x.shape;\n\tndims = shx.length;\n\n\t// Resolve the success criterion:\n\tN = n.accessors[ 0 ]( n.data, n.offset );\n\tif ( N < 1 ) {\n\t\treturn true;\n\t}\n\t// Determine whether we can avoid iteration altogether...\n\tif ( ndims === 0 ) {\n\t\tif ( x.accessorProtocol ) {\n\t\t\treturn ACCESSOR_SOME[ ndims ]( x, N, predicate, thisArg );\n\t\t}\n\t\treturn SOME[ ndims ]( x, N, predicate, thisArg );\n\t}\n\t// Check whether we were provided an empty ndarray...\n\tif ( numel( shx ) === 0 ) {\n\t\treturn false;\n\t}\n\t// Determine whether we can avoid blocked iteration...\n\tif ( ndims <= MAX_DIMS && iterationOrder( x.strides ) !== 0 ) {\n\t\t// So long as iteration always moves in the same direction (i.e., no mixed sign strides), we can leverage cache-optimal (i.e., normal) nested loops without resorting to blocked iteration...\n\t\tif ( x.accessorProtocol ) {\n\t\t\treturn ACCESSOR_SOME[ ndims ]( x, N, predicate, thisArg );\n\t\t}\n\t\treturn SOME[ ndims ]( x, N, predicate, thisArg );\n\t}\n\t// Determine whether we can perform blocked iteration...\n\tif ( ndims <= MAX_DIMS ) {\n\t\tif ( x.accessorProtocol ) {\n\t\t\treturn BLOCKED_ACCESSOR_SOME[ ndims-2 ]( x, N, predicate, thisArg );\n\t\t}\n\t\treturn BLOCKED_SOME[ ndims-2 ]( x, N, predicate, thisArg );\n\t}\n\t// Fall-through to linear view iteration without regard for how data is stored in memory (i.e., take the slow path)...\n\tif ( x.accessorProtocol ) {\n\t\treturn accessorsomend( x, N, predicate, thisArg );\n\t}\n\treturn somend( x, N, predicate, thisArg );\n}\n\n\n// EXPORTS //\n\nmodule.exports = someBy;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Test whether at least `n` elements in an ndarray pass a test implemented by a predicate function.\n*\n* @module @stdlib/ndarray-base-some-by\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var scalar2ndarray = require( '@stdlib/ndarray-from-scalar' );\n* var someBy = require( '@stdlib/ndarray-base-some-by' );\n*\n* function predicate( value ) {\n*    return value > 0.0;\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 0.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create the input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Define the success criterion:\n* var n = scalar2ndarray( 3, {\n*     'dtype': 'generic'\n* });\n*\n* // Test elements:\n* var out = someBy( [ x, n ], predicate );\n* // returns true\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome2d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "ox1", "sh", "s0", "s1", "sx", "ox", "ix", "i0", "i1", "j0", "j1", "o", "require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome3d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "ox1", "ox2", "sh", "s0", "s1", "s2", "sx", "ox", "ix", "i0", "i1", "i2", "j0", "j1", "j2", "o", "require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome4d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "ox1", "ox2", "ox3", "sh", "s0", "s1", "s2", "s3", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "j0", "j1", "j2", "j3", "o", "require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome5d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "ox1", "ox2", "ox3", "ox4", "sh", "s0", "s1", "s2", "s3", "s4", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "j0", "j1", "j2", "j3", "j4", "o", "require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome6d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "ox1", "ox2", "ox3", "ox4", "ox5", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "j0", "j1", "j2", "j3", "j4", "j5", "o", "require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome7d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "ox1", "ox2", "ox3", "ox4", "ox5", "ox6", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "o", "require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome8d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "ox1", "ox2", "ox3", "ox4", "ox5", "ox6", "ox7", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "o", "require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome9d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "dx8", "ox1", "ox2", "ox3", "ox4", "ox5", "ox6", "ox7", "ox8", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "j8", "o", "require_d_blocked_accessors", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome10d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "dx8", "dx9", "ox1", "ox2", "ox3", "ox4", "ox5", "ox6", "ox7", "ox8", "ox9", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "i9", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "j8", "j9", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome2d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "ox1", "sh", "s0", "s1", "sx", "ox", "ix", "i0", "i1", "j0", "j1", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome3d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "ox1", "ox2", "sh", "s0", "s1", "s2", "sx", "ox", "ix", "i0", "i1", "i2", "j0", "j1", "j2", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome4d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "ox1", "ox2", "ox3", "sh", "s0", "s1", "s2", "s3", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "j0", "j1", "j2", "j3", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome5d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "ox1", "ox2", "ox3", "ox4", "sh", "s0", "s1", "s2", "s3", "s4", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "j0", "j1", "j2", "j3", "j4", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome6d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "ox1", "ox2", "ox3", "ox4", "ox5", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "j0", "j1", "j2", "j3", "j4", "j5", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome7d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "ox1", "ox2", "ox3", "ox4", "ox5", "ox6", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome8d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "ox1", "ox2", "ox3", "ox4", "ox5", "ox6", "ox7", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome9d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "dx8", "ox1", "ox2", "ox3", "ox4", "ox5", "ox6", "ox7", "ox8", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "j8", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "take", "reverse", "blockedsome10d", "x", "n", "predicate", "thisArg", "bsize", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "dx8", "dx9", "ox1", "ox2", "ox3", "ox4", "ox5", "ox6", "ox7", "ox8", "ox9", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "sx", "ox", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "i9", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "j8", "j9", "o", "require_d_accessors", "__commonJSMin", "exports", "module", "some0d", "x", "n", "predicate", "thisArg", "require_d_accessors", "__commonJSMin", "exports", "module", "some1d", "x", "n", "predicate", "thisArg", "count", "xbuf", "get", "dx0", "S0", "ix", "i0", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some2d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "sh", "S0", "S1", "sx", "ix", "i0", "i1", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some3d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "sh", "S0", "S1", "S2", "sx", "ix", "i0", "i1", "i2", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some4d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "sh", "S0", "S1", "S2", "S3", "sx", "ix", "i0", "i1", "i2", "i3", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some5d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "sh", "S0", "S1", "S2", "S3", "S4", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some6d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some7d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some8d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some9d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "dx8", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "require_d_accessors", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some10d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "get", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "dx8", "dx9", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "i9", "require_nd_accessors", "__commonJSMin", "exports", "module", "numel", "vind2bind", "ind2sub", "MODE", "somend", "x", "n", "predicate", "thisArg", "count", "xbuf", "ordx", "idx", "len", "get", "sh", "sx", "ox", "ix", "i", "require_d", "__commonJSMin", "exports", "module", "some0d", "x", "n", "predicate", "thisArg", "require_d", "__commonJSMin", "exports", "module", "some1d", "x", "n", "predicate", "thisArg", "count", "xbuf", "dx0", "S0", "ix", "i0", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some2d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "sh", "S0", "S1", "sx", "ix", "i0", "i1", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some3d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "sh", "S0", "S1", "S2", "sx", "ix", "i0", "i1", "i2", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some4d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "sh", "S0", "S1", "S2", "S3", "sx", "ix", "i0", "i1", "i2", "i3", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some5d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "sh", "S0", "S1", "S2", "S3", "S4", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some6d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some7d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some8d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some9d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "dx8", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "require_d", "__commonJSMin", "exports", "module", "strides2order", "zeroTo", "reverse", "take", "some10d", "x", "n", "predicate", "thisArg", "count", "xbuf", "idx", "dx0", "dx1", "dx2", "dx3", "dx4", "dx5", "dx6", "dx7", "dx8", "dx9", "sh", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "sx", "ix", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "i9", "require_nd", "__commonJSMin", "exports", "module", "numel", "vind2bind", "ind2sub", "MODE", "somend", "x", "n", "predicate", "thisArg", "count", "xbuf", "ordx", "idx", "len", "sh", "sx", "ox", "ix", "i", "require_main", "__commonJSMin", "exports", "module", "iterationOrder", "ndarray2object", "numel", "blockedaccessorsome2d", "blockedaccessorsome3d", "blockedaccessorsome4d", "blockedaccessorsome5d", "blockedaccessorsome6d", "blockedaccessorsome7d", "blockedaccessorsome8d", "blockedaccessorsome9d", "blockedaccessorsome10d", "blockedsome2d", "blockedsome3d", "blockedsome4d", "blockedsome5d", "blockedsome6d", "blockedsome7d", "blockedsome8d", "blockedsome9d", "blockedsome10d", "accessorsome0d", "accessorsome1d", "accessorsome2d", "accessorsome3d", "accessorsome4d", "accessorsome5d", "accessorsome6d", "accessorsome7d", "accessorsome8d", "accessorsome9d", "accessorsome10d", "accessorsomend", "some0d", "some1d", "some2d", "some3d", "some4d", "some5d", "some6d", "some7d", "some8d", "some9d", "some10d", "somend", "SOME", "ACCESSOR_SOME", "BLOCKED_SOME", "BLOCKED_ACCESSOR_SOME", "MAX_DIMS", "someBy", "arrays", "predicate", "thisArg", "ndims", "shx", "x", "n", "N", "main"]
}
